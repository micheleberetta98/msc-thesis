\section{The context}

\section{The web}
\subsection{Basic structure}
\subsection{The web browser}
\subsection{JavaScript}

\section{WebAssembly}
\subsection{Description and motivations}

\textit{WebAssembly} \cite{wasm-website} is a binary instruction format for a stack-based virtual machine.
It is designed to be a portable compilation target, so that different languages can be deployed on the web.

Nowadays, web application's need are more sophisticated and demanding, such as 3D visualization, audio and video,
games and so on. Efficiency and security are then important points that must be addressed, however JavaScript,
as the de-facto standard language on the web, is not able to meet these requirements.

WebAssembly main goals are \cite{bringing-the-web-up-to-speed-2017} to be:
\begin{itemize}
  \item \textit{Safe}, in particular to provide the same memory safety as a managed language;
  \item \textit{Fast}, by using ahead-of-time optimizations in a similar manner as native machine code;
  \item \textit{Portable}, since the web spans many device, architectures, operating systems and browsers;
  \item And finally \textit{compact}, because code is transmitted over the network and must reduce load times as much as possible.
\end{itemize}

There were previous attempt at solving the problem of having safe, fast and portable low-level code on the Web,
such as \textit{ActiveX}, \textit{Native Client} and \textit{asm.js}.

\textit{ActiveX} \cite{activex} was a Microsoft's technology for code-signing x86 binaries to run on the web, and relied only
on this signing. Hence, it achieved safety through a trust model, not through technical construction.
\textit{Native Client} \cite{native-client} introduced the first sandboxing technique for x86, ARM or MIPS machine code,
which was statically validated. Lastly, \textit{asm.js} \cite{asmjs} is a specialized subset of JavaScript, which is on of the target
languages of \textit{Emscripten} \cite{emscripten}, a compiler toolchain able to compile C/C++ applications in order to have them
run on browsers or on \textit{Node.js}\footnote{ Emscripten also supports WebAssembly output.}.

\subsection{Overview}

\subsection{Problems with WebAssembly}
\subsection{WebAssembly as a fault isolation tool}
\subsection{WASI - WebAssembly System Interface}

\section{Linux Security Modules}

The \textit{Linux Security Module} (LSM) \cite{lsm-2002} \cite{kernel-lsm}
is a lightweight, general purpose, access control framework for the Linux Kernel.
It provides a mechanism for various security checks to be hooked by kernel extensions.
These extensions are not loadable kernel modules, but they can either be choosen at
compile-time via specific flags, such as \texttt{CONFIG\_DEFAULT\_SECURITY}, or overridden at boot-time.

The LSM is used primarily by \textit{Mandatory Access Control} (MAC) extensions to
provide a security policy. However, other extensions can be built with the LSM framework
in order to implement specific changes when they cannot be obtained with the functionality Linux itself.

Some projects that use LSM include:
\begin{itemize}
  \item \textit{SELinux} \cite{selinux}, i.e.\ \textit{Security Enhanced Linux}, that provides a mechanism for supporting advanced and fine-grained access control policies, as well as MAC;
  \item \textit{Smack} \cite{smack}, a kernel based implementation of MAC with simplicity as one of its primary goals;
  \item \textit{AppArmor} \cite{apparmor}, a MAC style security extension that implements a task centered policy.
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{lsm-hook-architecture.png}
  \caption{LSM Hook Architecture, from \cite{kernel-lsm}}
  \label{fig:lsm-hook-architecture}
\end{figure}

\subsection{Landlock}
\textit{Landlock} \cite{landlock-kernel} \cite{landlock-user-space} is a security feature available since Linux 5.13
that uses the LSM framework in order to provide scoped access control,
so that any process, even when unprivileged, can securely restrict itself.
This can help mitigate the security impact of bugs or unexpected/malicious behaviour
in user space applications.

Landlock employes the concept of \textit{rule}, which describes an action
on an object. An object is (currently) a file hierarchy, and actions are
defined with access rights, such as executing, reading or writing files, making
symbolic links and so on.
A set of rules is called a \textit{ruleset}, and it can restrict both the thread
using it and its future children, created either by spawning a new thread, as well
as using the \textit{fork} system call.

Notably, Landlock does not permits the definition of exeptions.
For example, suppose we have a directory \texttt{dir1}, which contains two files
\texttt{file1} and \texttt{file2}. We can define a ruleset that allows
reading and writing files for \texttt{dir1}.
However, if we then define another ruleset comprising only of read operations
for \texttt{file1}, the permissions specified for \texttt{dir1} are still
valid, so when a process restricts itself it is still able to write to \texttt{file1}.

In case of multiple consecutive self-restrictions, the result is the intersection
of all rulesets - if a process first restricts itself allowing all read and writing operations,
and then restricts itself again with only reading permissions, the result is equivalent
to a single restriction made with a ruleset that permits only reading operations.

Landlock can be used directly when writing C/C++ code in Linux thanks to the
\texttt{<linux/landlock.h>}\footnote{Examples of code available at \cite{landlock-user-space}}
header, or by using libraries that provide these binding to other languages,
such as \texttt{go-landlock}\footnote{\url{https://github.com/landlock-lsm/go-landlock}}
for Go and \texttt{rust-landlock}\footnote{\url{https://github.com/landlock-lsm/rust-landlock}} for Rust.

\subsection{eBPF}
\textit{eBPF} \cite{ebpf} is a virtual machine in the Linux Kernel that can run sandboxed programs
in a privileged context. It can be used to safely extend the capabilities of the kernel
without requiring to change kernel source code or load kernel modules.

Application developers can run eBPF programs in order to add additional capabilities at runtime,
and then the operating system guarantees safety and efficiency as if natively compiled
by using a Just-In-Time compiler.
These eBPF programs are event-driven and run when a certain hook point is passed. Some
pre-defined hooks include system calls, network events, and so on. If a hook does not exist,
it's possible to create custom kernel or user probes.

Unlike Landlock, eBPF makes it possible to define specific exception, e.g.\ denying
certain access rights on specific files while allowing them on the containing directory.
It also allows to specify wether a program has access to devices such as \texttt{terminal}
and \texttt{dev}.

Thanks to \texttt{BPFContain}\footnote{\url{https://github.com/willfindlay/bpfcontain-rs}}
it's also possible to run a container security daemon by leveraging eBPF.  In this case,
specific policies must be written for desired commands.