\section{The context}

\section{The web}
\subsection{Basic structure}
\subsection{The web browser}
\subsection{JavaScript}

\section{WebAssembly}
\subsection{Description and motivations}

\textit{WebAssembly} \cite{wasm-website} is a binary instruction format for a stack-based virtual machine.
It is designed to be a portable compilation target, so that different languages can be deployed on the web.
It was announced in 2015 and implemented by major browsers by 2017, and as of May 2022 is supported
by 93\% of all browsers\footnote{\url{https://caniuse.com/?search=WebAssembly}}.

Nowadays, web application's need are more sophisticated and demanding, such as 3D visualization, audio and video,
games and so on. Efficiency and security are then important points that must be addressed, however JavaScript,
as the de-facto standard language on the web, is not able to meet these requirements.
WebAssembly main goals are hence to be \cite{bringing-the-web-up-to-speed-2017}:
\begin{itemize}
  \item \textit{Safe}, in particular to provide the same memory safety as a managed language;
  \item \textit{Fast}, by using ahead-of-time optimizations in a similar manner as native machine code;
  \item \textit{Portable}, since the web spans many device, architectures, operating systems and browsers;
  \item And finally \textit{compact}, because code is transmitted over the network and must reduce load times as much as possible.
\end{itemize}

There were previous attempt at solving the problem of having safe, fast and portable low-level code on the Web,
such as \textit{ActiveX}, \textit{Native Client} and \textit{asm.js}.

\textit{ActiveX} \cite{activex} was a Microsoft's technology for code-signing x86 binaries to run on the web, and relied only
on this signing. Hence, it achieved safety through a trust model, not through technical construction.
\textit{Native Client} \cite{native-client} introduced the first sandboxing technique for x86, ARM or MIPS machine code,
which was statically validated. Lastly, \textit{asm.js} \cite{asmjs} is a specialized subset of JavaScript, which is on of the target
languages of \textit{Emscripten} \cite{emscripten}, a compiler toolchain able to compile C/C++ applications in order to have them
run on browsers or on \textit{Node.js}.

WebAssembly is available as a target for various languages, such as C/C++ with the aid of Emscripten, Rust,
AssemblyScript\footnote{A language with a syntax similar to TypeScript.}, Go, Kotlin, Swift and Zig.
The compiled binary can be then used from JavaScript on the web, or with Node.js or Deno, or even as a CLI application
with the aid of the \textit{WebAssembly System Interface} (see Section \ref*{sec:introduction-wasi}).

\subsection{Overview of the language}

Although WebAssembly is a binary code format, it can also be written with \textit{S-expressions}
in order to be more readable.
Each binary takes the form of a \textit{module}, which contains \textit{functions}, \textit{global} variables,
\textit{tables} and \textit{memories}. Each of these can be exported to be used in the embedder, and a module can also import functionalities.
While a module is a static representation of a program, an \textit{instance} is the dynamic one.
A module can be instantiated by the embedder (e.g.\ a JavaScript virtual machine).

\begin{lstlisting}[language=wasm, caption={Recursive factorial written in WebAssembly S-expressions}, label=lst:wasm-fact]
  (module
    (func $fact (param $x i64) (result i64)
      (if (result i64) (i64.eqz (local.get $x))
        (then (i64.const 1))
        (else
          (i64.mul
            (local.get $x)
            (call $fact
              (i64.sub (local.get $x) (i64.const 1)))))))
    (export "fact" (func $fact)))
\end{lstlisting}

WebAssembly is a typed language, but there are only four basic \textit{value types} - integers and IEEE 754 floating
point numbers, each in 32 and 64 bit variants. There are no distinction between signed and unsigned integers,
but instructions that depends on signedness are marked with an explicit suffix.

\textit{Functions} are typed, take a sequence of values as a parameter and returns another sequence of values.
They cannot be nested inside each other. The content of the call stack for execution are separate from the data
portion of the memory, and cannot be accessed directly by WebAssembly.
The code inside a function consists of a series of \textit{instructions} that modify an implicit operand stack,
either by declaring local variables or applying operations to the value already on the stack.
Functions can be called either \textit{directly} by using an index that identifies a function, or \textit{indirectly},
i.e.\ dynamically through a global \textit{table}. In this second case, only the function's type signature is validated.

WebAssembly has also support for \textit{traps} - in a similar manner to an exception, a trap aborts the current
computation, and control is given back to the embedder. For example, when embedded in JavaScript, a trap will
throw a JavaScript exception.

The main storage that WebAssembly uses is a \textit{linear memory} (or simply \textit{memory}), that is represented
by an array of bytes. Each module can defined no more than one memory, which can grow when needed with a unit size
of 64 KiB, a \textit{page}. This memory is separated by the call stack and by the memory dedicated to code.
Moreover, all pointers, when present, are translated into offsets in the linear memory, and all memory accesses are bound-checked.

Another main difference from other stack machines is that WebAssembly doesn't provide arbitrary jumps but
\textit{structured control flow}, so that the code can be validated in a single pass and prevent common control flow attacks.

\subsection{Problems with WebAssembly}

Since languages with manual memory management, such as C/C++, can be compiled into WebAssembly,
it is natural to ponder how memory vulnerabilities affect WebAssembly binaries.
In the original paper it is said that ``a buggy or exploited WebAssembly program can make a mess of the data in its own memory''
\cite{bringing-the-web-up-to-speed-2017}, in light of the fact that the call stack is not accessible by the program.

However, as shown in \cite{binary-security-wasm-2020}, even though WebAssembly strives for safety,
binaries can be still exploited with both traditional attacks,
such as buffer overflows, and attacks that aren't applicable in traditional native binaries, e.g.\ overwriting
string literals in memory.

The paper shows that it is possible to obtain a write primitive given a WebAssembly binary compiled from vulnerable C/C++ code,
by means of stack-based buffer overflows and heap metadata corruption, and it is possible to overwrite stack, heap and ``constant''
data, since the linear memory does not have a read-only section. It would be possible then, for example, to overwrite the name
of a file that was encoded as a string literal in the original program.

Another problem shown in the same paper is the redirection of indirect calls. Since WebAssembly allows indirect calls
to functions through a function table, an attacker could divert the execution by overwriting an integer in linear memory
that serves as an index into the table section. WebAssembly limits this ability with two mechanisms - not all functions
may appear in the table, but only those that can be indirectly called, and all functions call are type checked.
So, redirecting indirect calls is possible only within the class of functions with the same type.

Lastly, it is possible to enable remote code execution when including vulnerable WebAssembly in an application.
This is because functions that have different types in one language can be mapped onto functions with the same type
in WebAssembly. For example, a log functions that in C has the signature \texttt{void log(int)}, and a function such as
\texttt{void exec(const char* cmd)} both become functions with only one \texttt{i32} param in WebAssembly.
This enables the indirect divertion described in the previous paragraph if the two functions can be indirectly called.

\subsection{WebAssembly as a fault isolation tool}
\subsection{WASI - WebAssembly System Interface}
\label{sec:introduction-wasi}

\section{Linux Security Modules}

The \textit{Linux Security Modules} (LSM) \cite{lsm-2002, kernel-lsm}
is a lightweight, general purpose, access control framework for the Linux Kernel.
It provides a mechanism for various security checks to be hooked by kernel extensions.
These extensions are not loadable kernel modules, but they can either be chosen at
compile-time via specific flags, such as \texttt{CONFIG\_DEFAULT\_SECURITY}, or overridden at boot-time.

The LSM is used primarily by \textit{Mandatory Access Control} (MAC) extensions to
provide a security policy. However, other extensions can be built with the LSM framework
in order to implement specific changes when they cannot be obtained with the functionality Linux itself.

Some projects that use LSM include:
\begin{itemize}
  \item \textit{SELinux} \cite{selinux}, i.e.\ \textit{Security Enhanced Linux}, that provides a mechanism for supporting advanced and fine-grained access control policies, as well as MAC;
  \item \textit{Smack} \cite{smack}, a kernel based implementation of MAC with simplicity as one of its primary goals;
  \item \textit{AppArmor} \cite{apparmor}, a MAC style security extension that implements a task centered policy.
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{lsm-hook-architecture.png}
  \caption{LSM Hook Architecture, from \cite{kernel-lsm}}
  \label{fig:lsm-hook-architecture}
\end{figure}

\subsection{Landlock}
\textit{Landlock} \cite{landlock-kernel, landlock-user-space} is a security feature available since Linux 5.13
that uses the LSM framework in order to provide scoped access control,
so that any process, even when unprivileged, can securely restrict itself.
This can help mitigate the security impact of bugs or unexpected/malicious behavior
in user space applications.

Landlock employs the concept of \textit{rule}, which describes an action
on an object. An object is (currently) a file hierarchy, and actions are
defined with access rights, such as executing, reading or writing files, making
symbolic links and so on.
A set of rules is called a \textit{ruleset}, and it can restrict both the thread
using it and its future children, created either by spawning a new thread, as well
as using the \textit{fork} system call.

Notably, Landlock does not permits the definition of exceptions.
For example, suppose we have a directory \texttt{dir1}, which contains two files
\texttt{file1} and \texttt{file2}. We can define a ruleset that allows
reading and writing files for \texttt{dir1}.
However, if we then define another ruleset comprising only of read operations
for \texttt{file1}, the permissions specified for \texttt{dir1} are still
valid, so when a process restricts itself it is still able to write to \texttt{file1}.

In case of multiple consecutive self-restrictions, the result is the intersection
of all rulesets - if a process first restricts itself allowing all read and writing operations,
and then restricts itself again with only reading permissions, the result is equivalent
to a single restriction made with a ruleset that permits only reading operations.

Landlock can be used directly when writing C/C++ code in Linux thanks to the
\texttt{<linux/landlock.h>}\footnote{Examples of code available at \cite{landlock-user-space}}
header, or by using libraries that provide these binding to other languages,
such as \texttt{go-landlock}\footnote{\url{https://github.com/landlock-lsm/go-landlock}}
for Go and \texttt{rust-landlock}\footnote{\url{https://github.com/landlock-lsm/rust-landlock}} for Rust.

\subsection{eBPF}
\textit{eBPF} \cite{ebpf} is a virtual machine in the Linux Kernel that can run sandboxed programs
in a privileged context. It can be used to safely extend the capabilities of the kernel
without requiring to change kernel source code or load kernel modules.

Application developers can run eBPF programs in order to add additional capabilities at runtime,
and then the operating system guarantees safety and efficiency as if natively compiled
by using a Just-In-Time compiler.
These eBPF programs are event-driven and run when a certain hook point is passed. Some
predefined hooks include system calls, network events, and so on. If a hook does not exist,
it's possible to create custom kernel or user probes.

Unlike Landlock, eBPF makes it possible to define specific exception, e.g.\ denying
certain access rights on specific files while allowing them on the containing directory.
It also allows to specify whether a program has access to devices such as \texttt{terminal}
and \texttt{dev}.

Thanks to \texttt{BPFContain}\footnote{\url{https://github.com/willfindlay/bpfcontain-rs}}
it's also possible to run a container security daemon by leveraging eBPF.  In this case,
specific policies must be written for desired commands.