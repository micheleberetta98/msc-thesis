\section{The context}

\section{The web}
\subsection{Basic structure}
\subsection{The web browser}
\subsection{JavaScript}

\section{WebAssembly}
\subsection{Description and motivations}

\textit{WebAssembly} \cite{wasm-website} is a binary instruction format for a stack-based virtual machine.
It is designed to be a portable compilation target, so that different languages can be deployed on the web.

Nowadays, web application's need are more sophisticated and demanding, such as 3D visualization, audio and video,
games and so on. Efficiency and security are then important points that must be addressed, however JavaScript,
as the de-facto standard language on the web, is not able to meet these requirements.

WebAssembly main goals are \cite{bringing-the-web-up-to-speed-2017} to be:
\begin{itemize}
  \item \textit{Safe}, in particular to provide the same memory safety as a managed language;
  \item \textit{Fast}, by using ahead-of-time optimizations in a similar manner as native machine code;
  \item \textit{Portable}, since the web spans many device, architectures, operating systems and browsers;
  \item And finally \textit{compact}, because code is transmitted over the network and must reduce load times as much as possible.
\end{itemize}

There were previous attempt at solving the problem of having safe, fast and portable low-level code on the Web,
such as \textit{ActiveX}, \textit{Native Client} and \textit{asm.js}.

\textit{ActiveX} \cite{activex} was a Microsoft's technology for code-signing x86 binaries to run on the web, and relied only
on this signing. Hence, it achieved safety through a trust model, not through technical construction.
\textit{Native Client} \cite{native-client} introduced the first sandboxing technique for x86, ARM or MIPS machine code,
which was statically validated. Lastly, \textit{asm.js} \cite{asmjs} is a specialized subset of JavaScript, which is on of the target
languages of \textit{Emscripten} \cite{emscripten}, a compiler toolchain able to compile C/C++ applications in order to have them
run on browsers or on \textit{Node.js}\footnote{ Emscripten also supports WebAssembly output.}.

\subsection{Overview}

Although WebAssembly is a binary code format, it can also be written with \textit{S-expressions}
in order to be more readable.
Each binary takes the form of a \textit{module}, which contains \textit{functions}, \textit{global} variables,
\textit{tables} and \textit{memories}. Each of these can be exported to be used in the embedder.
A module can also import functionalities.
While a module is a static representation of a program, an \textit{instance} is the dynamic one.
A module can be instantiated by the embedder (e.g.\ a JavaScript virtual machine).

\begin{lstlisting}[language=wasm, caption={Factorial written in WebAssembly S-expressions}, label=lst:wasm-fact]
  (module
    (func $fact (param $x i64) (result i64)
      (if (result i64) (i64.eqz (local.get $x))
        (then (i64.const 1))
        (else
          (i64.mul
            (local.get $x)
            (call $fact
              (i64.sub (local.get $x) (i64.const 1)))))))
    (export "fact" (func $fact)))
\end{lstlisting}

WebAssembly is a typed language, but there are only four basic \textit{value types} - integers and IEEE 754 floating
point numbers, each in 32 and 64 bit variants. There are no distinction between signed and unsigned integers,
but instructions that depends on signedness are marked with an explicit suffix.

\textit{Functions} are typed, take a sequence of values as a parameter and returns another sequence of values.
They cannot be nested inside each other. The content of the call stack for execution are separate from the data
portion of the memory, and cannot be accessed directly by WebAssembly.
The code inside a function consists of a series of \textit{instructions} that modify an implicit operand stack,
either by declaring local variables or applying operations to the value already on the stack.
Functions can be called either \textit{directly} by using an index that identifies a function, or \textit{indirectly},
i.e.\ dynamically through a global \textit{table}.

WebAssembly has also support for \textit{traps} - in a similar manner to an exception, a trap aborts the current
computation, and control is given back to the embedder. For example, when embedded in JavaScript, a trap will
throw a JavaScript exception.

The main storage that WebAssembly uses is a \textit{linear memory} (or simply \textit{memory}), that is represented
by an array of bytes. Each module can defined no more than one memory, which can grow when needed with a unit size
of 64 KiB, a \textit{page}.

Another main difference from other stack machines is that WebAssembly doesn't provide arbitrary jumps but
\textit{structured control flow}, so that the code can be validated in a single pass.

\subsection{Problems with WebAssembly}
\subsection{WebAssembly as a fault isolation tool}
\subsection{WASI - WebAssembly System Interface}

\section{Linux Security Modules}

The \textit{Linux Security Module} (LSM) \cite{lsm-2002} \cite{kernel-lsm}
is a lightweight, general purpose, access control framework for the Linux Kernel.
It provides a mechanism for various security checks to be hooked by kernel extensions.
These extensions are not loadable kernel modules, but they can either be chosen at
compile-time via specific flags, such as \texttt{CONFIG\_DEFAULT\_SECURITY}, or overridden at boot-time.

The LSM is used primarily by \textit{Mandatory Access Control} (MAC) extensions to
provide a security policy. However, other extensions can be built with the LSM framework
in order to implement specific changes when they cannot be obtained with the functionality Linux itself.

Some projects that use LSM include:
\begin{itemize}
  \item \textit{SELinux} \cite{selinux}, i.e.\ \textit{Security Enhanced Linux}, that provides a mechanism for supporting advanced and fine-grained access control policies, as well as MAC;
  \item \textit{Smack} \cite{smack}, a kernel based implementation of MAC with simplicity as one of its primary goals;
  \item \textit{AppArmor} \cite{apparmor}, a MAC style security extension that implements a task centered policy.
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{lsm-hook-architecture.png}
  \caption{LSM Hook Architecture, from \cite{kernel-lsm}}
  \label{fig:lsm-hook-architecture}
\end{figure}

\subsection{Landlock}
\textit{Landlock} \cite{landlock-kernel} \cite{landlock-user-space} is a security feature available since Linux 5.13
that uses the LSM framework in order to provide scoped access control,
so that any process, even when unprivileged, can securely restrict itself.
This can help mitigate the security impact of bugs or unexpected/malicious behavior
in user space applications.

Landlock employs the concept of \textit{rule}, which describes an action
on an object. An object is (currently) a file hierarchy, and actions are
defined with access rights, such as executing, reading or writing files, making
symbolic links and so on.
A set of rules is called a \textit{ruleset}, and it can restrict both the thread
using it and its future children, created either by spawning a new thread, as well
as using the \textit{fork} system call.

Notably, Landlock does not permits the definition of exceptions.
For example, suppose we have a directory \texttt{dir1}, which contains two files
\texttt{file1} and \texttt{file2}. We can define a ruleset that allows
reading and writing files for \texttt{dir1}.
However, if we then define another ruleset comprising only of read operations
for \texttt{file1}, the permissions specified for \texttt{dir1} are still
valid, so when a process restricts itself it is still able to write to \texttt{file1}.

In case of multiple consecutive self-restrictions, the result is the intersection
of all rulesets - if a process first restricts itself allowing all read and writing operations,
and then restricts itself again with only reading permissions, the result is equivalent
to a single restriction made with a ruleset that permits only reading operations.

Landlock can be used directly when writing C/C++ code in Linux thanks to the
\texttt{<linux/landlock.h>}\footnote{Examples of code available at \cite{landlock-user-space}}
header, or by using libraries that provide these binding to other languages,
such as \texttt{go-landlock}\footnote{\url{https://github.com/landlock-lsm/go-landlock}}
for Go and \texttt{rust-landlock}\footnote{\url{https://github.com/landlock-lsm/rust-landlock}} for Rust.

\subsection{eBPF}
\textit{eBPF} \cite{ebpf} is a virtual machine in the Linux Kernel that can run sandboxed programs
in a privileged context. It can be used to safely extend the capabilities of the kernel
without requiring to change kernel source code or load kernel modules.

Application developers can run eBPF programs in order to add additional capabilities at runtime,
and then the operating system guarantees safety and efficiency as if natively compiled
by using a Just-In-Time compiler.
These eBPF programs are event-driven and run when a certain hook point is passed. Some
predefined hooks include system calls, network events, and so on. If a hook does not exist,
it's possible to create custom kernel or user probes.

Unlike Landlock, eBPF makes it possible to define specific exception, e.g.\ denying
certain access rights on specific files while allowing them on the containing directory.
It also allows to specify whether a program has access to devices such as \texttt{terminal}
and \texttt{dev}.

Thanks to \texttt{BPFContain}\footnote{\url{https://github.com/willfindlay/bpfcontain-rs}}
it's also possible to run a container security daemon by leveraging eBPF.  In this case,
specific policies must be written for desired commands.