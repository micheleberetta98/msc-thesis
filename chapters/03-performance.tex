\section{Testing plan}

The main goals of this performance testing plan are:
\begin{itemize}
  \item to find out whether the usage of LSM implies some sort of performance penalty;
  \item to identify possible improvable points when embedding WebAssembly in another language.
\end{itemize}

\noindent
For a given program, the following different builds are tested:
\begin{itemize}
  \item the native binary, obtained through \texttt{rustc}, run directly;
  \item the native binary run with Landlock and through eBPF;
  \item the WebAssembly binary run directly by \textit{Wasmtime};
  \item the WebAssembly binary run by the developed program with Landlock enabled and disabled;
  \item the WebAssembly binary run through eBPF (using \textit{Wasmtime}).
\end{itemize}

\subsection{System and hardware}

The system and hardware used for both the development of the project described in Section \ref{sec:restricting-wasi-landlock}
and the performed test is as follows:
\begin{itemize}
  \item Arch Linux as the operating system, more specifically the 2022.05.01 version;
  \item an Intel Core i5-7200U quad-core with a clock rate of 2.5 GHz;
  \item 8 GB of RAM;
  \item a 120 GB solid state disk.
\end{itemize}

The choice of the operating system is mainly dictated by the fact that Arch Linux has both Landlock and eBPF active
out of the box, removing the need to compile the Linux kernel with the necessary flags to enable these
functionalities.

\subsection{Tests' description}

The performed tests are:
\begin{itemize}
  \item a purely computational program, given by the sorting of 10000 random numbers as in Listing \ref{lst:sorting-test-rust},
        in order to measure the pure computational impact of the various methods;
  \item a simple reading of files of various sizes as in Listing \ref{lst:reading-test-rust}, with only the necessary permissions enabled on
        a case by case bases, in order to test the sandbox provided and how they fare against native binaries.
\end{itemize}

\vspace*{0.5cm}
\begin{code}[language=Rust, caption=The tested sorting program., label=lst:sorting-test-rust]
use rand::Rng;

fn main() {
  let mut rng = rand::thread_rng();
  let mut vec: Vec<i32> = Vec::new();

  for _ in 0..10000 {
    vec.push(rng.get::<i32>());
  }

  vec.sort();
}
\end{code}

\begin{code}[language=Rust, caption=The tested reading program., label=lst:reading-test-rust]
fn main() {
  // Change the filename to test different file sizes
  let _content =
    std::fs::read_to_string("./input-file.txt");
}
\end{code}

The reading file test is repeated with different file sizes\footnote{Randomly generated by using \texttt{/dev/urandom}.},
which are $100$ KB, $1$ MB, $10$ MB and $100$ MB. By doing this, it is possible to see how performance
varies when dealing with progressively large files.

\subsection{Performance indicators}

The main performance indicators will be the mean execution time, measured in milliseconds, together with its
standard deviation in order to compensate for variability.
These measures are always obtained from a sample of 100 runs, executed and measured by \texttt{hyperfine},
a command-line benchmarking tools \cite{hyperfine}, and finally saved to a
JSON file\footnote{All results are available in JSON and image format at \url{https://github.com/micheleberetta98/wasm-performance-testing}.}.

\section{Comparison between different methods}

\subsection{Landlock and eBPF on a native binary}

\subsection{Landlock and eBPF on a WebAssembly binary}

\section{Comparison between a restricted and an unrestricted binary}

\subsection{Landlock on a WebAssembly binary}

\subsection{eBPF on a WebAssembly binary}

\section{Internal analysis of the developed project}

\subsection{Performance impact of Landlock}

\subsection{Performance impact of using a WASI library}